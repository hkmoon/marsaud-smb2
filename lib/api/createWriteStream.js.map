{"version":3,"sources":["src/createWriteStream.js"],"names":["path","options","cb","createDisposition","flags","err","file","SmbWritableStream","fibonacci","requestAsync","promisify","maxPacketSize","a","b","c","connection","encoding","start","offset","chunk","next","Buffer","isBuffer","packetSize","Math","min","toNumber","length","packet","slice","add","retryInterval","pending","FileId","Offset","toBuffer","code","resolve","reject","setTimeout","value","args"],"mappings":"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","file":"createWriteStream.js","sourcesContent":["import Bigint from '../tools/bigint'\nimport Bluebird from 'bluebird'\nimport {request} from '../tools/smb2-forge'\nimport {Writable} from 'stream'\n\nimport {\n  FILE_OPEN,\n  FILE_OPEN_IF,\n  FILE_OVERWRITE_IF,\n  FILE_CREATE\n} from '../structures/constants'\n\nconst requestAsync = Bluebird.promisify(request)\n\nconst maxPacketSize = new Bigint(8, 0x00010000 - 0x71)\n\nfunction * fibonacci () {\n  let a = 1\n  let b = 2\n\n  for (;;) {\n    const c = a\n    a = b\n    b = c + a\n    yield c\n  }\n}\n\nclass SmbWritableStream extends Writable {\n  constructor (connection, file, options = {}) {\n    super(options)\n\n    const {\n      encoding = 'utf8',\n      start = 0\n    } = options\n\n    this.connection = connection\n    this.encoding = encoding\n    this.file = file\n    this.offset = new Bigint(8, start)\n  }\n\n  async _write (chunk, encoding, next) {\n    encoding = this.encoding || encoding\n    chunk = Buffer.isBuffer(chunk) ? chunk : new Buffer(chunk, encoding)\n\n    while (chunk.length > 0) {\n      const packetSize = Math.min(maxPacketSize.toNumber(), chunk.length)\n      const packet = chunk.slice(0, packetSize)\n      chunk = chunk.slice(packetSize)\n      const offset = new Bigint(this.offset)\n      this.offset = this.offset.add(packetSize)\n\n      const retryInterval = fibonacci()\n      let pending = true\n\n      while (pending) {\n        try {\n          await requestAsync('write', {\n            FileId: this.file.FileId,\n            Offset: offset.toBuffer(),\n            Buffer: packet\n          }, this.connection)\n\n          pending = false\n        } catch (error) {\n          if (error.code === 'STATUS_PENDING') {\n            await new Promise((resolve, reject) => {\n              setTimeout(resolve, retryInterval.next().value)\n            })\n          } else {\n            throw error\n          }\n        }\n      }\n    }\n\n    next()\n  }\n\n  async end (...args) {\n    try {\n      super.end(...args)\n    } finally {\n      await requestAsync('close', this.file, this.connection)\n    }\n  }\n}\n\nexport default function (path, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  let createDisposition\n  const flags = options && options.flags\n\n  if (flags === 'r') {\n    createDisposition = FILE_OPEN\n  } else if (flags === 'r+') {\n    createDisposition = FILE_OPEN_IF\n  } else if (flags === 'w' || flags === 'w+') {\n    createDisposition = FILE_OVERWRITE_IF\n  } else if (flags === 'wx' || flags === 'w+x') {\n    createDisposition = FILE_CREATE\n  }\n\n  request('create', { path, createDisposition }, this, (err, file) => {\n    if (err) {\n      cb(err)\n    } else {\n      cb(null, new SmbWritableStream(this, file, options))\n    }\n  })\n}\n"]}